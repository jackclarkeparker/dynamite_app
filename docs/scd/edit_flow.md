# Edit flow for SCD model instances

With any SCD model instances, the #update action of their respective controller will not cause in-place modification of an existing record. Instead it will lead to a new record being created, with the original having it's `valid_until` column set to a timestamp of when the update action is executed.  

If the new version specified by the inputs of an edit template does not pass validation, then the action will rerender the edit template anew. In order for this to be carried out smoothly, some preparation is necessary:   
1. We want for the values specified in the preceding failed update-submission to be persisted to the rerendering; this ensures that error messages displayed are contiguous with the user-submitted values, and that they don't "disappear before their eyes". For this to be the case, we need to set the `@<model>` to `new_version`.
     - This has to do with some magic that `form_with` relies on behind-the-scenes to populate the `value` attribute of the inputs included in the form being rendered. `form_with` looks for an instance variable with a name matching the value passed to the `:model` (or `:scope`) option passed to `form_with`. This instance variable will reference a model instance. Each attribute-value of this instance then will set the corresponding HTML input's `value` attribute in the form, which is what is used for a default value for the input to be populated with.
2. However, if our `@<model>` references `new_version`, then it won't carry an appropriate `id` to be used in the `action` attribute of the form that will be generated (which is what determines the endpoint that the form is submitted to). We need an update action to act on the existing entity instance, not a new_version that doesn't exist in the database. So, before we lose access to the original model instance in the reassignment of `@<model>` described earlier, we want to capture it's `id` in an instance variable `@original_id`.  
     - Later, when it comes time to render the form again with `form_with`, we can't simply pass the `:model` option, as that invocation style requires that the `:scope` and `:url` for the form submission are both obtainable from the value passed to `:model`. Instead, we've got to invoke `form_with` with the `:scope` and `:url` options - `:scope` allows us to pass the `@<model>` instance variable to retrieve the default values for inputs with, and `:url` allows us to specify the end-point for the form submission.  

We have two different `form_with` invocations to carry out, depending on whether the `edit` being rendered is for an initial `#update` form submission, or a resubmission following a failed attempt. Therefore the `edit.html.erb` template includes a conditional that will either render a `_failed_edit` partial, or just the regular `_form` partial. These two partials include their respective `form_with` invocations, as well as the `submit` input - this is so that `_failed_edit` can manually set the value to be displayed for the `submit` input, which otherwise is automatically set to a value that is incorrect. In determining which conditional clause to evaluate, the test expression is for another instance variable set up by preparation, `render_failed_edit`, which simply carries a boolean value and makes explicit the distinction between the rendering of one `form_with` partial or the other.

Finally, we have two partials used to render the edit page, but both should use the same set of inputs; we want any modifications to these inputs to be reflected in both partials. These now live in a `_form_inputs.html.erb` partial that is rendered by both `_failed_edit` and `_form`.